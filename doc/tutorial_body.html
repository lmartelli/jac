<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>Tutorial</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <link rel="stylesheet" type="text/css" href="../basic.css" title="basic style">
  </head>
<body>

    <h1><a name="0">Warning</a></h1> <p>JAC is still beta software
    released for developers who know what they are doing. It is
    developed and tested under Linux and should work out of the box
    on any Unix-like system. It should be very easy to make it run on
    Windows by using the furnished <code>scripts/org.objectweb.jac.bat</code> script
    (however, the compilation scripts should be ported).</p>

    <h1><a name="1"></a>Getting started</h1>

    <h2><a name="install"></a>Installation of JAC</h2>
    
    <p>To use JAC, download a JAC release at the <a
	href="../downloads.html" target="_parent">downloads</a> section.
      JAC uses several libraries that you can find on the Internet.

    <p><b>Simple installation</b>: you can simply download the JAC
      version with libraries included (since version 4.1). With this
      choice, the JAC installation is easier and you do not need to
      install all the following (except JDK1.3).
      
    <p><b>Complex installation</b>: download the JAC version with no
      libraries included and install the following libraries
      separatly from JAC.

    <ul>
      <li>mandatory: <a
	  href="http://java.sun.com/products/" target="_top">jdk 1.3 or
	  jdk 1.4</a></li>
 
<li>mandatory: <a href="http://jakarta.apache.org/bcel/">BCEL</a></li>

<li>mandatory: gnu-regexp (<a
	  href="http://www.cacas.org/java/gnu/regexp/" target="_top">http://www.cacas.org/java/gnu/regexp/</a>)</li>

<li>mandatory: <a
	  href="http://www.cs.princeton.edu/~appel/modern/java/CUP/" target="_top">cup</a></li>

<li>for XML parsing: libxerces-java</li>

<li>for persistence (optional): postgresql JDBC driver (see <a
	  href="http://www.postgresql.org/software.html" target="_top">http://www.postgresql.org/software.html</a>)</li>

<li>for web access: <a
 href="http://jetty.mortbay.org/jetty/download.html">Jetty 4.1</a>(4.0
 has problems decoding charsets in URLs but should work fine if you do
 only deal with english content)</li>

<li>for the IDE: support for UML diagrams (<a
 href="http://jhotdraw.sourceforce.net" target="_top">http://jhotdraw.sourceforce.net</a>)</li>

</ul>

<p>and to compile JAC:

<ul><li>tcl (used to generate the makefiles)</li>

<li>jikes (recommended <a href="http://oss.software.ibm.com/developerworks/opensource/jikes/" target="_top">http://oss.software.ibm.com/developerworks/opensource/jikes/</a>)</li>
    
</ul>

<p>Once you have installed all you need, install JAC and initialize the environment:

<ol>
      <li>Extract the archive:

<pre class=code>
cd &lt;work_dir&gt;
tar zxf org.objectweb.jac.xxx.tar.gz
</pre>
</li>

    <li>Set environment variables. All the java libraries must be in
      your CLASSPATH, and JAC_ROOT must be set. You can customise
      <code>scripts/init_env</code> and then source it <em>in the root
      directory</em> of the distribution:

<pre class=code>
source scripts/init_env [JAC_ROOT directory]
</pre>

	<p class=warning><b>WARNING</b>: under Windows, the
	  <code>scripts/init_env</code> script will not work. You
	  should use the <code>scripts/org.objectweb.jac.bat</code> script that sets
	  the class path. This script assumes that you installed JAC
	  in <code>C:\jac</code>. If you installed it somewhere else,
	  you should edit <code>org.objectweb.jac.bat</code> and change the
	  definition of <code>JAC_ROOT</code> and
	  <code>CLASSPATH</code>.</p>

      </li>

      <li> Since version 0.5.1, we distribute a jar file along with the
	sources, so this step is optional. So if you choose to compile
	the sources (should work fine under Linux, may need some
	adaptations under Windows), edit <code>Make.rules</code> if
	needed (for instance if you want to use javac instead of jikes),
	and run make:
<pre class=code>
make
</pre>
      </li>
    </ol>
      
    <h2><a name=samples></a>Running JAC samples</h2>
    
    <h3><a name=requirements></a>Requirements</h3>
    
    <p>You should have performed all the needed steps described in the
    <i>Installation of JAC</i> section. Here is a quick reminder in
    case your samples do not work.

    <ul>      
      <li>Your CLASSPATH should contain all the needed components.</li>
      <li>You may use the init_env script to set your environment
	variables. Edit it, and then source it. </li>
    </ul>
      
      <h3><a name=compile></a>Compile the sample (Linux)</h3>
    
    <p>Each sample has a makefile in its directory that is
      automatically generated by the global make. If you compiled JAC,
      normally the samples are already compiled.
      
      <h3><a name=persistence></a>Configure the persistence aspect (if needed
      by the sample)</h3>
    
    <p class=note>Note: to know if a sample needs the persistence
	aspect, go in the sample directory and see if its contains
	<code>persistence.acc</code> file (i.e. a configuration file
	for persistence). However, if you do not want to use
	persistence at a first try, edit the .jac file of the sample,
	remove the line that adds the persistence aspect to the
	application (or switch the last parameter to false). The
	sample will then run in a transient mode (all the
	modifications you make on the objects will be forgotten if you
	restart the program).</p>

    <p>Two kinds of storage are available : filesystem and SQL. The
      filesystem storage allows you to store objects in plain files on
      your local filesystem. SQL storages allow you to store objects
      in an SQL database. Only Postgresql is supported for the moment,
      but adding other databases is very easy.</p>

    <p>By default, the samples use the filesystem storage and stores
    data files in a directory relative to <code class=env>JAC_ROOT</code></p>
      
    <h4>Configuring the filesystem storage</h4>

    <p>All you need to do is to specify a directory where object files
    will stored in the persistence.acc :</p>

<pre class=code>
configureStorage org.objectweb.jac.aspects.persistence.FSStorage {
   "&lt;directory&gt;" };
</pre>

    <p>The directory does not need to exist. It will be created if it does not
    exist.</p>

    <h4>Configuring the Postgresql storage</h4>

    <p>The <code>src/org/objectweb/jac/aspects/persistence/createdb.sql</code>
      script creates the tables needed by the aspect (<strong>note
      that you need to have postgresql and a fully installed account
      that allows you to create databases in order to perform this
      step</strong>):
      
<pre class="code">
createdb photo
psql photo < createdb.sql
</pre>
    
    <p>Customize the configureStorage line in persistence.acc. The syntax is:
      
<pre class="code">
configureStorage &lt;storage_class&gt; {
  "&lt;db_name&gt;", "&lt;db_user&gt;", "&lt;db_password&gt;" };
</pre>
    
    <p>Since Postgresql is the only supported database for the moment,
      <code>&lt;storage_class&gt;</code> is
      <code>org.objectweb.jac.aspects.persistence.PostgresStorage</code>. Note that
      if you change the sample program structure, the database may become
      inconsistent with the application.
      
    <h3><a name="run_sample"></a>Run the sample with JAC</h3>
    
    <p>In any directory, run jac with the *.jac file path as a last
    argument.
      
<pre class="code">
jac -G main src/org/objectweb/jac/samples/photos/photos.jac
</pre>

    <p>It will launch JAC and the photos sample class with the Swing
      GUI (-G option). The <code>main</code> parameter after the
      <code>-G</code> is the name of the window to display. For more
      details about <a href="javadoc/org/objectweb/jac/core/Jac.html">starting
      options</a>.</p>

    <h3><a name="run_dist"></a>Run the sample in distributed mode</h3>

    <p>If the sample can run in a distributed mode (see the
      <code>*.jac</code> or if a <code>deployment.acc</code> file
      exists to know that), then you will need other JAC containers to
      be started elsewhere depending on how the deployment aspect is
      configured (see or modify the <code>deployment.acc</code> file
      of the sample). To allow the distribution aspect to work:
	  
    <ul>
      <li>Launch the number of servers required
	by the sample with
<pre class=code>
jac -D serverName
</pre>
	(the final
	server name is <code>//hostname/serverName</code>  where
	<code>hostname</code> is the TCP/IP name of the host the
	server is launched on and <code>serverName</code> is the given
	name). For more details about <a href="javadoc/org/objectweb/jac/core/Jac.html" target=Javadoc>starting options</a>.</li>
	
      <li>Skip the previous step for a
	local simulation (if you do not have several hosts with JAC on
	  them). Just use the <code>go</code> script that launches as
	many servers as you need and automatically names them
	(<code>go&nbsp;N</code> launches <code>//hostname/s1, //hostname/s2, ... //hostname/sN</code>)</li> 
      
      <li>Check that a <code>topology</code> property is defined in the
	application descriptor file (<code>*.jac</code>) of the sample.
	  Modify it so that it defines all the servers that you have
	  launched in the previous step.</li>

      <li>Check that a <code>deployment.acc</code> file exists in the
	 sample's directory and that the deployment rules it defines
	  correspond to the names of the servers you have launched
	(check the available <a
	href="javadoc/org/objectweb/jac/aspects/distribution/package-summary.html">aspects
	for distribution</a>). Check also that the <code>*.jac</code>
	 file declares the deployment aspect.</li>
      
      <li>Start the sample with the -D option so that JAC runs in
	distributed mode: <code>jac -G -D
	src/org/objectweb/jac/samples/ring/ring.jac</code>. Note that a JAC server
	is then created for deployment and is named
	<code>//localhost/s0</code>. This deployment server is used by
	the other servers as the global aspects configurations
	server.</li>
    </ul>

    <h3><a name="web"></a>Using the web interface</h3>

    <p>Then, just launch the application with the <code>-W</code>
    option:</p>
    
<pre class=code>
jac -W default calcul.jac
</pre>

    <p>In order to view an object with your browser, you just have to
      enter the following URL:
      <code>http://localhost:8080/org/objectweb/jac/default</code>.</p>

    <p>You can then perform any action you could perform with the
    swing GUI.</p>

<h1><a name="programming"></a>Programming the calcul sample</h1>

<p>Once you are ok with the JAC installation and environment, let us
      enter into details on how to program a sample application with
      JAC. We choose the calcul sample since it is a very simple one
      (available in the latest JAC distributions).

    <p>This tutorial allows you to go through JAC programming step by step 
      and in a very progressive way. For more general overview on the
      JAC's programming philosophy, see the <a
	href="programmer_guide_tot.html" target="_parent">JAC Programmer's Guide</a>.

    <h2><a name="prog_base"></a>Programming the base application</h2>

    <p>The base application is the functionnal or core-business
      application. In other words, it is the simpliest expression of
      your functionnal needs. Here, we would like to have a class that
      performs some simple calculi. Wherever you want, create a new
      directory <code>calcul</code> and, inside of it, a file called
      <code>Calcul.java</code>. The code is the following:

<pre class=code>
// Calcul.java file
// A simple component definition that can perform 
// add and sub operations...
public class Calcul {
   protected float value = 0;
   public void add(float toadd) {
      value+=toadd;
   }
   public void sub(float tosub) {
      value-=tosub;
   }
   // IMPORTANT: in JAC, each instance-field better have
   // a getter of the form getFieldName.
   public float getValue() {
      return value;
   }
   // IMPORTANT: in JAC, each instance-field better have 
   // a setter of the form setFieldName.
   public void setValue(float value) {
      this.value=value;
   }

   // Program entry-point
   public static void main( String[] args ) {
      // Actually launch the calcul program by creating an 
      // instance of the Calcul class that waits to be used...
      Calcul myCalcul = new Calcul();
   }
}
</pre>

<p>Note that the need of the getters and setters comes from the
      aspects that will use them later-on.

<p>In JAC, any application must have a program descriptor that we put
      in a *.jac file. This file declares the new application and the
      supported aspects to the JAC system.

<pre class=code>
// calcul.jac file
applicationName: calcul
launchingClass: Calcul
</pre>

    <p>The launching class is a regular class that contains a static
      <code>main</code> method. For simplicity, we put the <code
	class=method>main()</code> in the <code class=class>Calcul</code> class.

    <p>Compile these files like you are used to doing in Java
      (<code>*.jac</code> and <code>*.acc</code> files do not need to
      be compiled).</p>

<pre class=code>
javac Calcul.java
</pre>

    <p>When compiled, run the JAC server and indicate to launch the calcul
      sample. Note that all the classpath issues in Java are also
      present in JAC -- thus, you can add the calcul directory to the
      classpath (note that <code>*.acc</code> files are also fetched
      using the classpath, for this reason, you should beware of
      conflicts when modifying the classpath). Into the calcul
      directory (where <code>Calcul.class</code> and
      <code>Run.class</code> should be found), just run (assuming that
      <code>$JAC_ROOT/scripts/jac</code> is in your path):

<pre class=code>
jac calcul.jac
</pre>

    <p>Since no aspects are configured for the application, All you
    will see is this:</p>

<pre class=output>
--- Launching Application calcul ---
JAC system shutdown: notifying all ACs...
Bye bye.
</pre>

    <p>This is not very usefull, but is it prooves that JAC is working
      on your system.</p>

    <h2><a name="conf_rtti_gui"></a>Configuring the RTTI and GUI aspects</h2>

     <p><a href="javadoc/org/objectweb/jac/core/rtti/package-summary.html"
	  target=Javadoc>org.objectweb.jac.core.rtti</a> is a core aspect that
	  allows the programmer to define extra type information that
	  will be used by other aspects at runtime.

    <p>For instance, it can be very useful for other aspects to be
      aware that a given method modify the object's state. Since JAC
      can detect that automatically, we do not need to add specific
      configurations for our sample application. All you need to do is
      create an empty file <code class=file>rtti.acc</code>.

     <p>The <a href="javadoc/org/objectweb/jac/aspects/gui/GuiAC.html"
	  target=Javadoc>GUI aspect</a> allows the
	  programmer to define some presentation information, and to
	  parameterize the interactions between the application
	  objects and the user. For instance, by configuring a
	  personal GUI aspect, a programmer can define the names of
	  the method parameters as they will be displayed by a GUI.

<p>For our example, create a <code>gui.acc</code> file:

<pre class=code>
// configuration for the Calcul class
class Calcul {
   // Show a button for each of these methods
   setMethodsOrder {add,sub};
   // Set the names of the parameters of add and sub methods
   setParameterNames add { "Value to add" };
   setParameterNames sub { "Value to sub" };
   // Set a default value for add
   setDefaultValues add { 1 };
}

// Says that all the methods of class Calcul can be called interactively
askForParameters "Calcul";

// The GUI main window configuration
window default {
   registerCustomized;
   setTitle "Calculator";

   // A real simple GUI
   setSubPanesGeometry 1 VERTICAL { false };
   // Display the object named "calcul0" in the panel "0" of the window.
   setPaneContent 0 Object { "calcul0" };
}
</pre>
       
    <p>Once you have created you ACC files, you must declare them to the
      application by modifying the <code>calcul.jac</code> file as
      following:

<pre class=code>
// calcul.jac file
applicationName: calcul
launchingClass: Calcul
aspects: \
  rtti rtti.acc true \
  gui gui.acc true
</pre>
 
    <p>You can then launch the application with the following command:</p>

<pre class=code>
jac -G default calcul.jac
</pre>

    <p>And you should see a window like this:</p>

    <div class=figure>
      <img src="images/calcul1.png" alt="The calcul sample main window">
    </div>
    
    <p>As you can see, the calcul instance is being
    introspected by the GUI aspect of JAC that offers a default view
    on it. It shows the fields of the <code>calcul0</code> object
    (here <code class=field>value</code>, and the methods that can be
    called on the object (the two buttons <code
    class=method>add</code> and <code>sub</code>)). The pencil-like
    button <img src="images/small_edit.gif" alt="Edit icon"> on the right of
    the field means that you can edit the field value by calling the
    field's setter. Click on it to change the value of the <code
    class=field>value</code> field. The following box pops-up. Type
    a new value:</p>

    <div class=figure>
      <img src="images/calcul2.png" alt="Edit box for value">
    </div>

    <p>When you click on OK, you can notice that the view is
      automatically refreshed. Indeed, thanks to bytecode analysis,
      JAC knows that <code>setValue</code> is a setter for the
      <code>value</code> field. Thus the MVC (Model-View-Controller)
      underlying framework of the GUI aspect refreshes the view.

    <p>Let us now try the <code>add</code> button:</p>
    <div class=figure>
      <img src="images/calcul3.png" alt="Edit box for value">
    </div>

    <p>You will first notice that the default value to be added is
    "1". This is because of the <code
    class=method>setDefaultValues</code> instruction in the <code
    class=file>gui.acc</code>. When you click on OK, once again the
    view of the main window is automatically refreshed because JAC
    detected that the <code class=method>add</code> method modifies
      the field <code class=field>value</code>.</p>

    <p>All this configuration works also with the WEB. If you launch JAC
      with the WEB-GUI server:

<pre class=code>
jac -W default calcul.jac
</pre>

    <p>You will see the following output on the console:</p>

<pre class=output>
--- Launching Application calcul ---
WARNING: Resource rtti.acc not found
13:34:52.863 EVENT  Starting Jetty/4.1
13:34:53.832 EVENT  Started HttpContext[/jac]
13:34:53.841 EVENT  Started HttpContext[/org/objectweb/jac/resources]
13:34:54.295 EVENT  Started SocketListener on 0.0.0.0:8088
13:34:54.306 EVENT  Started org.mortbay.http.HttpServer@100bac2
WARNING: Web server already started
</pre>

    <p>Then, with you favorite web browser, go to <code class=url>http://localhost:8088/org/objectweb/jac/default</code>:</p>

    <div class=figure>
      <img src="images/calcul4.png" alt="The calcul sample screenshot">
    </div>


    <h2><a name="conf_other"></a>Configuring other aspects</h2>

    <p>Other aspects are available and can be configured using the
    same process that the one depicted for the RTTI and GUI aspects.

    <p>Some other useful aspects to configure are:      
    <ul>
      <li><a href="javadoc/org/objectweb/jac/aspects/tracing/TracingAC.html"
	  target=Javadoc>tracing</a></li>
      <li><a href="javadoc/org/objectweb/jac/aspects/tracing/DebuggingAC.html"
	  target=Javadoc>debugging</a></li>
      <li><a href="javadoc/org/objectweb/jac/aspects/persistence/PersistenceAC.html"
	  target=Javadoc>persistence</a></li>
      <li><a href="javadoc/org/objectweb/jac/aspects/authentication/AuthenticationAC.html"
	  target=Javadoc>authentication</a></li>
    </ul>


    <p class=note><b>NOTE</b>: This tutorial will be soon completed
      with other aspect configurations and programming. For the
      moment, you can follow the same rules to configure other aspects
      (see the furnished samples) and you can refer to the <a
      href="programmer_guide.html" target="_parent">JAC Programmer's Guide</a> and to
      the <a href="javadoc/" target="API">JAC API documentation</a>
      for further details.</p>


    <h2><a name="prog_dist"></a>Using AOP to program distributed applications</h2>

    <p>JAC provides full support for distributed AOP. This means two
    things:

<ol>
<li>the distribution of the application can be performed simply by
	configuring the aspects of the
	<code>org.objectweb.jac.aspects.distribution</code> package</li>

<li>if you have cleany followed some basic programming rules, the
	functionnal program and the aspects it contains will be
	distributed without any problem or code reengineering</li>
</ol>

<p>Basically, the <a href="javadoc/org/objectweb/jac/aspects/distribution/DeploymentAC.html"
	  target=Javadoc>deployment aspect</a> provides a set of
	  deployment rules that the programmer can use to deploy its
	  application over a set of containers.

<p>If we take again the calcul example, you may intend to launch JAC
      in a distributed mode where a set of clients will access to one
      unique instance of calcul (here, <code>calcul0</code>) located
      on a server host.

<p>To allow this, first modify the application descriptor to tell that
      the application knows a set of two other containers, and
      activate the deployment aspect.

<pre class=code>
// calcul.jac file
applicationName: calcul
launchingClass: Run
aspects: \
    rtti mydirectory/rtti.acc true \
    gui mydirectory/gui.acc true \
    deployment mydirectory/deployment.acc true
topology: //localhost/s1 //localhost/s2
</pre>

<p>This means that, including the master host (called
      <code>//localhost/s0</code>), your JAC system will contain three
      local sites <code>s0, s1, s2</code>. If you want to locate
      <code>calcul0</code> on <code>s1</code>, just write an ACC file,
      <code>deployment.acc</code>:

<pre class=code>
// deploy the calcul0 object from s0 to s1
deploy ".*s0" "calcul0" ".*s1";
// create stubs to access calcul0 on s0 and s2
createStubsFor "calcul0" ".*1" ".*0 || .*2";
</pre>

<p>Then start 2 JAC servers (if an error occurs, check section
<a href="#run_dist">Run the sample in distributed mode</a>).

<pre class=code>
go 2
</pre>
 
<p>Then start the application in a distributed mode (this starts the
      master server) -- do not forget to move into the
      <code>calcul</code> directory if needed:

<pre class=code>
jac -G -D calcul.jac
</pre>

<p>If everything goes okay, you should be able to perform remote call
      from <code>s0</code> and <code>s2</code> to 
      <code>calcul0</code> on <code>s1</code>. To check this, you can
      launch remote GUIs on <code>s1</code> and <code>s2</code> from
      the master GUI by using the menu: <code>System -->
      Containers</code> and by selecting the remote container you need
      to start a GUI on, and by clicking the <code>"Launch remote
      GUI"</code> button.

<p>What is revolutionary with JAC is the ability to change the way the
      application is distributed without having to change the
      application's code or even to restart the servers (this is one
      of the benefits of our Dynamic and Distributed Aspect-Oriented
      Framework). For instance, if you finally want to say that
      <code>calcul0</code> is replicated on all the sites of the
      topology and in strong consistency, then you can change the
      deployment file:

<pre class=code>
// replicate the calcul0 object from s0 to all
replicate ".*s0" "calcul0" ".*";
</pre>

<p>And add a consistency protocol by configuring the <a href="javadoc/org/objectweb/jac/aspects/distribution/ConsistencyAC.html"
	  target=Javadoc>consistency aspect</a> (you must declare it in
	  your <code>.jac</code> file).

<pre class=code>
addStrongPushConsistency "calcul0" MODIFIERS ".*";
</pre>

<p>The <i>replicated-strong</i> protocol maintains the replicas in a
      consistency called <i>strong</i>, i.e. as soon as a modification
      occurs on one site, all the replicas on the other sites are
      modified the same way (the last two parameters indicate that the
      methods that modify the object state
      --<code>MODIFIERS</code>-- are <i>pushed</i> to the other
      replicas). To better understand how it works, you can play with
      this rule and change the <code>MODIFIER</code> argument into
      <code>"setValue(float):void || add(float):void"</code> to not
      push the modifications when the <code>sub</code> method is
      called (in our case, <code>MODIFIERS</code> equals to
      <code>"setValue(float):void || add(float):void ||
      sub(float):void"</code>) (for more details about pointcut
      expressions that are allowed when denoting methods sets, see the
      <a href="javadoc/org/objectweb/jac/core/MethodPointcut.html"
	  target=Javadoc>MethodPointcut</a> class.

<p>To apply this rule at runtime, you must declare the consistency
      aspect in your <code>.jac</code> class. Then you can (un)weave
      aspects at runtime. To (un)weave an aspect, (un)check the checkbox that
      corresponds to the aspect in the
      <code>Aspects</code> lower-left subwindow of the master host's
      GUI. You can replace an aspect configuration by modifying and
      saving the ACC file, unckecking the
      checkbox, then, when the unweaving is finished, check
      the checkbox again to activate the new configuration.

<p>Once you have fully understood how it works, you are ready to play
      with more advanced features. For instance, you can use the
      load-balancing aspect (see
      <a href="javadoc/org/objectweb/jac/aspects/distribution/LoadBalancingAC.html"
	  target="Javadoc">org.objectweb.jac.distribution.aspects.LoadBalancingAC</a>) to increase the
      load capability of your applications. For instance you can
      program a load-balanced calculator only by slightly changing the
      distribution aspects, and by adding a new ACC
      (<code>load-balancing.acc</code>):

<pre class=code>
// deployment.acc
replicate ".*s0" "calcul0" ".*";
</pre>

<pre class=code>
// consistency.acc
addStrongPushConsistency "calcul0" "MODIFIERS" ".*[1-2]";
</pre>
 
<pre class=code>
// load-balancing.acc
addRoundTripLoadBalancer "calcul0" ".*s0" ".*[1-2]";
</pre>

<p>With these three configurations, the calcul instance of
      <code>s0</code> is a load-balancer that performs a rountrip
      load-balancing algorithm to dispatch on <code>s1</code> and
      <code>s2</code>.

    <h2><a name="prog_aspects"></a>Programming new aspects</h2>

    <p>With the JAC software, we furnish a bunch of useful aspects
    that can be advantagely used to program distributed
    applications. However, since JAC is a young project and that we
    cannot think in advance of all the possible uses you can make out
    of such a software, most of the aspects we provide may lack useful
    configuration method or may not work fine for specific
    usages.

<p>Here is a uncomplete list of the aspects that can be provided to
      create more specific applications:

<ul>
<li>fault-tolerance</li>
<li>dynamic load-balancing (choses the less-loaded replica)</li>
<li>real-time (time constraints on the method invocations)</li>
<li>encryption of remote invocations</li>
<li>security, detection of Byzantin use of the application</li>
<li>mobility support (servers = mobile agents)</li>
<li>connexion / deconnexion of clients</li> 
<li>transaction support</li>
</ul>

<p>Moreover, existing aspects need extensions to be complete. For
instance:

<ul>
<li>persistence: the only implemented storage rely on
	PostgreSQL. Supports for other databases and even files are
	needed</li>
<li>GUI: contributions are welcome to improve the UI interactivity or
	to improve WEB support</li>
<li>distribution: some other thin-clients than WEB browsers could be
	supported, other consistencies may be supported  
</ul>

<p>As an example, we next show how to add a simple fault-tolerence
      support to the load-balancing aspect provided in the JAC
      distribution (see <a
      href="javadoc/org/objectweb/jac/aspects/distribution/LoadBalancingAC.html"
      target="Javadoc">org.objectweb.jac.distribution.aspects.LoadBalancingAC</a>).

      <p>Let us first recall the structuration of an aspect by showing
      the code for an aspect that checks that the <code>add</code> or
      <code>sub</code> method invocations on the <code>calcul0</code>
      instance so that it raises an error if the added value is
      greater than 100 or if the substracted value is greater than 
      50.

<pre class=code>
// MyCheckingAspect.java
// the aspect declaration:
class MyCheckingAspect extends AspectComponent {

  // at instantiation-time, you should define the pointcuts
  public MyCheckingAspect() {

    // this pointcut will make the add method of calcul0 
    // wrapped by an instance of checkingWrapper (an 
    // inner wrapper of this aspect), and more specifically 
    // by the wrapping-method "checkAdd"
    pointcut("calcul0","Calcul","add(float):void",
             CheckingWrapper.class.getName(),"checkAdd",
             false);
    // same principles for sub...
    pointcut("calcul0","Calcul","sub(float):void",
             CheckingWrapper.class.getName(),"checkSub",
             false);
  }

  // then define the wrappers (if you think that these
  // wrappers can be used by other aspect, you can make 
  // them public within a standalone class-file)
  public Class CheckingWrapper extends Wrapper() {
    // see the programmer's guide for details on the 
    // wrapping methods semantics...
    public Object checkAdd() throws Error {
      if( ((Integer)args(0)).intVal()>100 ) {
        throw new Error("bound excedeed when calling add!");
      }
    }
    public Object checkSub() throws Error {
      if( ((Integer)args(0)).intVal()>50 ) {
        throw new Error("bound excedeed when calling sub!");
      }
    }
  }
}
</pre>

<p>Note that this aspect is very specific since it can only be applied
      to the <code>calcul0</code> instance. To program generic
      aspects, you may refer to the <a
      href="programmer_guide.html">JAC programmer's
      Guide</a>. Configuration methods are a first step towards
      genericity since they allow the system to dynamically create the
      pointcuts with the interpretation of the Aspect-Component
      Configuration (ACC) files (<code>*.acc</code>).

<p>In this case, you can parametrize the creation of the pointcuts
      instead of hardcoding them in the aspect-component
      constructor. For instance, the following two files have exactly
      the same effect than the previous hardcoded aspect-component
      except that a simple change of the object's name in the
      configuration file allows the user of this aspect component to
      make it work on other instances of the <code>Calcul</code>
      class.

<pre class=code>
// MyCheckingAC.java:
class MyCheckingAC extends AspectComponent {

  // at configuration-time (just after the instantiation),
  // this configuration method can be called to define the 
  // pointcuts
  public void checkCalcul(String name) {

    // this pointcut will make the add method of the 
    // instance named "name" wrapped
    pointcut(name,"Calcul","add(float):void",
             CheckingWrapper.class.getName(),"checkAdd",
             false);
    // same principles for sub...
    pointcut(name,"Calcul","sub(float):void",
             CheckingWrapper.class.getName(),"checkSub",
             false);
  }

  // then, same as the hardcoded aspect...
  Class CheckingWrapper extends Wrapper() {
   (...)
  }
}
</pre>

<pre class=code>
// my-checking.acc:
checkCalcul "calcul0";
</pre>

    <p><b>NOTE:</b> to be able to use and declare your new aspect
      component in <code>*.jac</code> file, you should first declare
      them in the global <code>org.objectweb.jac.prop</code> file located in
      <code>$JAC_ROOT</code> (see the <code>org.objectweb.jac.acs</code> property).


    <p>The load-balancing aspect used in section <a href="#prog_dist">
	Using AOP to program distributed applications</a> follows the
	same structuration rules:


<pre class=code>
package org.objectweb.jac.aspects.distribution;

import org.objectweb.jac.core.*;
import org.objectweb.jac.core.dist.*;

import gnu.regexp.*;
import java.util.*;

/**
 * This Aspect Component allows the programmer to easily implement
 * load-balancing features for its application when JAC is running in
 * distributed mode.
 *
 * @author Renaud Pawlak
 * @version 0.5.2 */

public class LoadBalancingAC extends AspectComponent {

   /**
    * This configuration method allows the user to define a round-trip
    * load-balancer on a replication group.
    *
    * It assumes that a replication group exists on a set of host
    * denoted by replicaExpr. It also assumes that an
    * uncorrelated replica called wrappeeName exists on
    * hostName. Note that this distributed scheme can be
    * easilly obtained by configuring the deployment aspect for an
    * object myObject like this:
    *
    * replicated "myObject" ".*[1-6]";
    *
    * This means that myObject is replicated on all
    * the hosts one to six and that the replicas are strongly
    * consistent. Then, you can configure the load-balancing:
    *
    * addRoundTripLoadBalancer "photorepository0" ".*" "s0" ".*[1-6]";
    *
    * Note that the round-trip balancer (located on s0) changes the
    * replica it uses for each invocation. The followed sequence is
    * 1,2,3,4,5,6,1,2,3,4,5,6,1,...
    *
    * An alternative to the round-trip load-balancer is the random
    * load-balancer that randomly picks out the next replica to
    * use. This can be useful when a total decoralation is needed for
    * all clients.
    *
    * @param wrappeeName the name of the object that is replicated and
    * that will act as a load-balancer proxy 
    * @param methods a pointcut expression for the method that perform
    * the load-balancing (others perform local calls)
    * @param hostName the host where the proxy load-balances
    * @param replicaExpr a regular expression that matches all the
    * hosts of the topology where the replicas are located
    *
    * @see #addRandomLoadBalancer(String,String,String,String) */
    

   public void addRoundTripLoadBalancer( String wrappeeName,
                                         String methods,
                                         String hostName, 
                                         String replicaExpr ) {

      pointcut( wrappeeName, ".*", methods,
                new LoadBalancingWrapper( replicaExpr ),
                "roundTripBalance", hostName );
   }

   /**
    * This configuration method allows the user to define a random
    * load-balancer on a replication group.
    *
    * It follows the same principles as a round-trip balancer but
    * picks up the next replica to use randomly.
    * 
    * @see #addRoundTripLoadBalancer(String,String,String,String) */

   public void addRandomLoadBalancer( String wrappeeName,
                                      String methods,
                                      String hostName, 
                                      String replicaExpr ) {

      pointcut( wrappeeName, ".*", methods,
                new LoadBalancingWrapper( replicaExpr ),
                "randomBalance", hostName );
   }
   
   /**
    * This inner-wrapper handles the load-balancing wrapping methods that
    * actually implement the load-balancing algorithms. */

   public class LoadBalancingWrapper extends Wrapper {

      int count = 0;
      Vector replicas = null;
      Random random = new Random();
      String hostExpr;
      boolean doFill = true;

      public LoadBalancingWrapper( String hostExpr ) {
         this.hostExpr = hostExpr;
      }

      public void invalidate() {
         doFill = true;
      }

      /**
       * Performs a round-trip load-balancing. */

      public Object roundTripBalance() {
         if( doFill ) {
            replicas = Topology.getPartialTopology(hostExpr)
               .getReplicas( this.wrappee() );
         }
         if( replicas.size() == 0 ) {
            // none replicas where found, we perform a local call and 
            // will try to get them again on the next call
            doFill = false;
            return proceed();
         }
         if( count >= replicas.size() ) {
            count = 0;
         }
         return ((RemoteRef)replicas.get(count++)).invoke(this.method(),this.args());
      }

      /**
       * Performs a random load-balancing. */

      public Object randomBalance() {
         if( doFill ) {
            replicas = Topology.getPartialTopology(hostExpr)
               .getReplicas( this.wrappee() );
         }
         if( replicas.size() == 0 ) {
            // none replicas where found, we perform a local call and 
            // will try to get them again on the next call
            doFill = false;
            return proceed();
         }
         return ((RemoteRef)replicas.get(random.nextInt(replicas.size())))
            .invoke(this.method(),this.args());
      }
   }      
}
</pre>

    <h1><a name="ide"></a>Using the IDE</h1>

    <p>In the latest distributions, JAC provides an IDE that supports
    UML-like and UML for aspects so that it greatly simplifies the
    programmer's task.

    <h2><a name="ide_req">Requirements</a></h2> 
    
    <p>Since the IDE is a JAC application, you must make sure that the
      JAC distribution is correctly installed and configured as
      depicted in the <a href="tutorial.html">tutorial</a>.

    <h2><a name="warnings">Warnings</a></h2>
    
    <p>This IDE is still in a beta version. The core model is quite stable
      and you should be able to read your projects with upcomming JAC
      releases, however, class diagrams could be lost.

    <p>The supported modeling language is a subset of UML (it only
      supports class diagram), plus a set of new concepts to model
      aspects (aspect classes, pointcut relations, and groups).

    <p>We claim that when using aspect-oriented technology, the whole
      UML language is not actually needed since the program is
      expressed with its simpliest core-business form. All the
      complexity related to implementation and design is handled in
      the provided aspects. As a consequence, you might be disapointed
      if you try to use this IDE whithin a regular development process
      on regular OO or CB technologies (however, this IDE could be
      easily extended to support these if needed).

    <h2><a name="getting_started">Getting started</a></h2>

    <p>Make sure that JAC is correctly installed and launch the
    application descriptor located in <code>org/objectweb/jac/src/org/objectweb/jac/ide</code>:

<pre class=code>
jac $JAC_ROOT/src/org/objectweb/jac/ide/ide.jac
</pre>

    <p>When launched for the first time, the IDE appears as a window
      separated in 4 sub-panels. In the upper-left pannel, one can see
      a treeview that contains one single node called "projects". This
      sub-panel is the most important since it allows you to navigate
      in your projects and all the projects entities such as packages,
      diagrams, classes, or applications. The following list shows the
      hierachy of all the different entities manipulated by the IDE:

    <ul>
      
      <li><b>project</b> (<img src="images/project.gif"
      alt="Project icon">): An entity that represents a given project
	(packages and applications).

	<ul>

	  <li><b>package</b> (<img src="images/package.gif"
      alt="Package icon">): A package is a container for classes or
	    aspect classes. It can also contains subpackages if
	    needed.

	    <ul>
	      
	      <li><b>subpackage</b> (<img src="images/package.gif"
      alt="Package icon">): A child package (can have other
		children).</li>
	      
	      <li><b>class</b> (<img src="images/class.gif"
      alt="Class icon">): A class as defined in UML. In JAC, a
		class should represent a purely fonctional component
		dedicated to one precise task. It contains methods and
		attributes and can be related to other classes through
		relation links or inheritence links.
		
		<ul>
		  
		  <li><b>attribute</b> (<img src="images/attribute.gif"
      alt="Attribute icon">): An attribute is a data in a
		    class.</li>
		  
		  <li><b>method</b> (<img src="images/method.gif"
      alt="Method icon">): A method defines a treatment that
		    can be perfomed on the instances of the owning
		    class.</li>
		  
		  <li><b>relation link</b> (<img src="images/relation.gif"
      alt="Relation icon">): A relation link relates a
		    class to another class. In a method body, the ending
		    class can be reached by using the end role name.</li>
		  
		</ul>
	      </li>
	      
	      <li><b>aspect</b> (<img src="images/aspect.gif"
      alt="Aspect icon">): An aspect represents an aspect
		component in JAC. An aspect should be used to model
		crosscutting behaviors on a set of classes or
		instances. It can be defined in the same way as a
		class (attributes, methods, and relation links) but
		can also use pointcut links.

		<ul>
		  <li><b>pointcut link</b> (<img src="images/pointcut.gif"
      alt="Pointcut icon">): A pointcut link relates an
		    aspect to a class, an instance, or a set of
		    instances (a group). The end role of a pointcut
		    link defines a set of methods using a <a
		    href="programmer_guide.html#3.2.5">method pointcut definition</a>. The start
		    role must be equal to a method name in the aspect
		    so that this method can wrap all the methods
		    denoted by the end role.</li>
		</ul>
	      </li>
    
	      <li><b>instance</b> (<img src="images/instance.gif"
      alt="Instance icon">): This entity represent an instance
		of a class (as defined in UML). An instance can be
		defined by its name regarding the JAC naming
		conventions (i.e. the lowercased class name followed
		by the index of the instance regarding its creation
		order).</li>

	      <li><b>group</b> (<img src="images/group.gif"
      alt="Group icon">): This entity represents a set of
		instances denoted by two expressions: an <a
		href="programmer_guide.html#3.2.5">object pointcut definition</a> and a <a
		href="programmer_guide.html#3.2.5">class pointcut definition</a>. Groups allows
		the user to define heterogenous sets of objects that
		can be extended by an aspect if a pointcut link ends
		to the group.</li>
      
	      <li><b>diagram</b> (<img src="images/diagram.gif"
      alt="Diagram icon">): A diagram is the graphical representation of
		a set of package entities such as classes or aspects. It
		roughly correspond to an UML class diagram but with some
		features added and some other removed. The diagram is
		consistent with the entities of packages.</li>
	    </ul>
    
	</ul>

      <li><b>application</b> (<img src="images/application.gif"
      alt="Application icon">): An application represents a launchable
	piece of software. It defines a lauching code that should
	instanciate one of the classe defined in one of the project's
	packages. It also defines and configures the aspects that are
	woven to the application when it is run.
      
	<ul>
	  
	  <li><b>aspect configuration</b> (<img src="images/configAspect.gif"
      alt="Aspect configuration icon">): This entity represent the
	configuration of a given aspect for a given application.</li>
	  
	</ul>
      </li>
    
    </ul>
    
    <p>Using the treeview is simple. You can double-click on a given node
      to open it. You can use the right-click to show the available
      treatements on the entity. For instance, to create a new
      project, just right-click on the "projects" node and choose the
      "Add project" item.

    <p>The upper-right panel is used to edit diagrams. Once you have
      created a package in your project (using right-click on the
      treeview), create a diagram in this package. The upper-right
      panel will show a diagram editor that allows you to create and
      edit the entities of the owning package.

    <p>The two lower panels are used to provide a Widget-based
      representation of the currently selected entity in a
      diagram. The left one shows classes, aspects, instances, or
      groups. The right one shows relation and pointcut links,
      attributes, or methods. These two panels can be used to edit the
      model elements without using a graphical diagram editor (which
      is sometimes useful to avoid using the mouse to much).


    <h2><a name="creating_application">Creating an application</a></h2>

    <h3><a name="core_business">Modeling the core business</a></h3>

    <p>First create a new project using the right click on the "projects"
      node of the treeview. Call it "myProject" and choose the
      generation path (the directory where the Java code will be
      generated).

    <p>You then need to create a new package in your project to define the
      business classes. Right-click on "myProject" node and add a
      package that you can call "invoices".

    <p>Since it is nicer to model graphically, right-click on
      "invoices" and add a new diagram. Call it "business" since it
      will represent the core-busines model of the application. A
      diagram editor component should then open in the upper-right
      sub-panel.

    <div class=figure>
      <img src="images/ide1.png" alt="The JAC IDE">
    </div>

    <p>Click on the "New class" button (<img src="images/class.gif"
      alt="New class icon">) of the diagram editor toolbar and then
      click on the desktop where you want to locate the new class. A
      new class should appear with a default name (NewClass). You can
      modify its name by using the "Text tool" (<img
      src="images/TEXT1.gif" alt="Text tool icon">) button and click
      on the title or by using the lower-left sub-panel. Just call it
      "Invoices". This class represents a container for a set of
      invoices.

    <p>Now create in the same way an "Invoice" class. You can add an
      attribute by using the "Add attribute" button (<img
      src="images/attribute.gif" alt="Add attribute icon">) of the
      toolbar. Using the text tool, you can edit this attribute. You
      MUST follow the conventions in the attribute definition,
      i.e. <i>attribute_name:attribute_type</i>. The available types
      are the classes that are already created and all the builtin
      types (see in the main menu: <code>Tools --> Type
      repository</code>). Just set the attribute to
      "amount:double". With the same process, create an attribute
      "date:Date".

    <p>You can now create another class "Client" with an attribute
      "name:String".

    <div class=figure>
      <img src="images/ide2.png" alt="Classes are created">
    </div>

    <p>We can now relate the three classes together. Use the "New
      relation" button (<img src="images/relation.gif" alt="New
      relation icon">). Press the left button down on the "Invoices"
      class and, without releasing, move to the "Invoice" class and
      let the button up. A new relation link should be created with
      its default roles, names, and cardinalities. You can edit them
      on the diagram using the text tool, or in the lower-right
      sup-panel. Set the end cardinality to "0-*". Do the same to
      create a relation between "Invoice" and "Client" set the start
      cardinality to "0-*".

    <p>Please, also set the role names as shown in the following
    screenshot.

    <div class=figure>
      <img src="images/ide3.png" alt="The invoices.business
    class diagram">
    </div>

    
    <h3><a name="application">Creating the application</a></h3>

    <h4><a name="app_global_conf">Global configuration</a></h4> 

    <p>Once the core business is modeled, you should create a new
    application to make a running JAC program.

    <p>Right-click on the "myProject" node and choose "Add
    application". Call it "myFirstApplication" for instance. You can
    also program the launching code of the program (this code
    corresponds to the <code>static void main(String[] args)</code>
    method that is used as an entry point for the Java program).

    <p>In JAC, the idea of a lauching code is to create the root
      objects of the application that can be used to reach or create
      other objects via collections (relation links with "0-*" end
      cardinality) or references (relation links with "0-1" end
      cardinality).

    <p>In this case, we only need to create an "Invoices" instance
    since all the other objects are reachable from it (regarding the
    model). Thus, in the launching code editor, type the line:

<pre class=code>
new invoices.Invoices();
</pre>

    <div class=figure>
      <img src="images/ide4.png" alt="My first application
	global configuration">
    </div>

    <p>Note that the full name of the class is as expected the parent
      package path concated with the class name (this follows the Java
      conventions).

    <p>At this step, the application is ready to run. Validate and use the
      "Generate code" and the "Compile" commands by right-clicking on
      the "myProject" node. If something goes wrong, some error
      message(s) should appear in an errors dialog. If you do not
      figure out how to solve the problem, do not hesitate to <a
      href="mailto:jac-dev@org.objectweb.jac.aopsys.com">contact us</a>.

    <p>Since the application does not perform any treatment, it is not
      very interesting to launch it as is. Thus, we should add at
      least a GUI aspect so that the user of the application can
      create and manipulate the business objets.
 
    <h4><a name="app_gui">Configuring the RTTI/GUI aspect</a></h4>

    <p>The GUI aspect is one of the most useful aspect provided by JAC
      since it allows the programmer to configure how the business
      objects should be rendered and how the final user can interact
      with the application.

    <p>As any aspect in JAC, the GUI aspect provides a configuration
      interface <a href="javadoc/org/objectweb/jac/aspects/gui/GuiConf.html">GUIConf</a>
      that defines all the configuration methods that can be used during
      the configuration process. The programmer can refer these
      interfaces to know the available commands that can be used.

    <p>To add an aspect configuration to an application, right-click
      on the application node of the treeview and add a new aspect
      configuration.

    <p>First create an RTTI aspect (choose rtti for the aspect name
      and leave the aspect blank --- this is used when a personnal
      aspect is created in the IDE). No configuration is required for
      the moment.

    <div class=figure>
      <img src="images/ide5.png" alt="The RTTI aspect configuration">
    </div>

    <p>Then, create and configure the GUI aspect as shown in the
      following screenshots.

    <div class=figure>
      <img src="images/ide6.png" alt="The GUI aspect configuration">
    </div>

    <div class=figure>
      <img src="images/ide7.png" alt="The GUI aspect configuration">
    </div>

    <div class=figure>
      <img src="images/ide8.png" alt="The GUI aspect configuration">
    </div>

    <h3><a name="starting_app">Starting the application</a></h3>
    
    <p>Before starting, ensure that the code generation is ok by
      right-click on the project's node and "Generate code"+"Compile".
      
    <p>The application code and classes is then available in the
      generation directory (GEN_DIR) that you have choosen when you
      have created the project (you can change it by asking a view on
      the project).
      
    <p>Ensure that <code class=file>GEN_DIR/classes</code> is in your
      classpath.
      
    <p>Launch JAC with the application's desciptor that was
      automatically generated.

<pre class=code>
jac GEN_DIR/myFirstApplication/myFirstApplication.jac
</pre>

    <h2><a name="notes">Important notes</a></h2>

    <p>The JAC's IDE helps the programmer to design JAC applications
    and allows him to easily configure existing aspects (the ones that
    are provided by the JAC distribution). However, for the moment,
    the knowlege of the aspect configuration interfaces is still
    needed. In a short future, the IDE will provide some graphical
    customization means that will make the programmer task easier.

    <p>With the IDE, the programmer can also create entirely new
      aspects despite it is not documented yet.


    <div class=footer>
      JAC is a LGPL software developed by the CAOLAC group of the
      CEDRIC Laboratory with the collaboration of the AproDis project
      of the <a href="http://www.lip6.fr" target="_top">LIP6</a> Laboratory and of
      the <a href="http://www.aopsys.com" target="_top">AOPSYS</a> (TM) company.<br>
      JAC is a direct application of the <a
      href="http://cedric.cnam.fr/~pawlak" target="_top">Renaud Pawlak</a> PhD
      Thesis.<br> It is written in Java, SUN (TM) and is the
      continuation of the <a href="http://www.aopsys.com/tos"
      target="_top">TOS project</a> (written in Tcl).
    </div>

</body>
</html>

